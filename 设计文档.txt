
表结构为
账户表
CREATE TABLE `accounts` (
  `account_id` bigint(36) NOT NULL AUTO_INCREMENT COMMENT '账户ID',
  `account_type` int(11) NOT NULL DEFAULT '1' COMMENT '账户类型:1:借记卡',
  `balance` decimal(18,2) NOT NULL COMMENT '账户余额',
  `currency` char(3) COLLATE utf8mb4_bin NOT NULL COMMENT '货币',
  `version` int(11) NOT NULL DEFAULT '0' COMMENT '修改版本',
  `created_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) COMMENT '创建时间',
  `updated_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) COMMENT '修改时间',
  PRIMARY KEY (`account_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=10000000005 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

交易表
CREATE TABLE `transactions` (
  `transaction_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '事务ID',
  `biz_id` varchar(32) COLLATE utf8mb4_bin NOT NULL COMMENT '业务ID',
  `source_account` bigint(36) NOT NULL COMMENT '源账户ID',
  `target_account` bigint(36) NOT NULL COMMENT '目前账户ID',
  `amount` decimal(18,2) NOT NULL COMMENT '转账金额',
  `status` enum('PENDING','PROCESSING','RETRY','FAILED','SUCCESS') COLLATE utf8mb4_bin NOT NULL COMMENT '交易状态',
  `retry` int(11) NOT NULL DEFAULT '0' COMMENT '重试次数',
  `error` varchar(128) COLLATE utf8mb4_bin NOT NULL COMMENT '错误信息',
  `created_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) COMMENT '创建时间',
  `updated_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) COMMENT '更新时间',
  `currency` char(3) COLLATE utf8mb4_bin NOT NULL DEFAULT 'CNY' COMMENT '货币',
  PRIMARY KEY (`transaction_id`),
  UNIQUE KEY `biz_id` (`biz_id`,`source_account`,`target_account`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;


接口
1. 创建账户
POST /api/v1/accounts
Content-Type: application/json

{
  "currency": "CNY"
}

Response (200 OK):
{
    "statusCode": 0,
    "data": {
        "accountId": "100000001",
        "balance": 0.00,
        "currency": "CNY",
        "created": "2023-09-20T10:00:00Z"
    }
}


账户ID从 100100000001 开始，每次加1 自增

2. 获取账户信息
GET /api/v1/accounts/{accountId}

Response (200 OK):
{
    "statusCode": 0,
    "data": {
        "accountId": "100100000001",
        "balance": 1500.50,
        "currency": "CNY",
        "created": "2023-09-20T10:00:00Z",
        "updated": "2023-09-20T10:05:00Z"
    }
}

3. 处理交易

POST /api/v1/transactions
Content-Type: application/json

{
  "bizId": "txn_123456ABB",
  "sourceAccount": "100100000001",
  "targetAccount": "100102000012",
  "currency": "CNY",
  "amount": 100.50
}

Response (200 OK):
{
    "statusCode": 0,
    "data": {
        "bizId": "txn_123456ABB",
        "status": "PENDING",
        "created": "2023-09-20T10:00:00Z"
    }
}


4. 获取交易状态
GET /api/v1/transactions/{bizId}

Response (200 OK):
{
    "statusCode": 0,
    "data": {
        "bizId": "txn_123456ABB",
        "status": "SUCCESS",
        "amount": 100.50,
        "sourceAccount": "100100000001",
        "targetAccount": "100102000012",
        "created": "2023-09-20T10:00:00Z",
        "updated": "2023-09-20T10:00:05Z"
    }
}

数据库使用 MySQL 5.7.x
缓存使用redis 6.2.x
使用jdk21 + spring boot 3.4.1 webflux 实现后端接口：
核心接口处理逻辑
一：处理交易接口
1：基于bizId实现幂等性，基于version实现乐观锁
a：先在redis 以bizId 加分布式锁，获取锁后，新增 transactions记录 ，一开始为pengding 状态，
b:校验：
  1：source 和 target 不能一致
  2：查询source 账户是否存在，且账户余额是否>= amount,
  3：查询target 账户是否存在，currency和AccountType和source账户是否一致
  4：检查 Transaction 请求的 currency和source账户是否一致
  校验失败，返回异常原因，记录该transactions记录为FAILED，并写入失败原因
c:校验成功后，使用乐观锁更新source 账户和target 账户，
  开启事务
  更新transactions 记录为PROCESSING
  乐观锁需要重试，sleep 50(n+1)ms 后重试，n为重试次数，n最大3，，重试时候，retry = retry+1
  超过3 ，则transactions记录更新为 RETRY，
  如果3次内成功，更新transactions记录为SUCCESS
  结束事务
d：释放分布式锁，返回transaction状态



二：异步重试任务
有一个5分钟+随机60秒 间隔的定时任务，定时查询 transactions status=“RETRY” 或者 “PENGDING” ,"PROCESSING" 且 now - 5min > updated 的记录
重新处理交易：
a:使用基于bizId获取分布式锁，如果没获取到，则跳过，处理下一条记录
b：如果获取到锁，如果retry > 6 次，则置为FAILED ，error 写为重试超过最大次数，需要人工介入，注释：发送告警短信通知人工介入。
   如果retry <6 ,重复 一：处理交易接口的 b,c步骤
c:释放分布式锁

三：缓存
查询接口可以加上redis 缓存，TTL设置2小时，比如账户，和transactions记录
如果账户余额更新，或者transactions记录的状态更新，需要删除对应的缓存
四：异常处理
1：异常处理，比如redis 获取锁失败，或者数据库操作失败，或者分布式锁释放失败，需要定义一个错误码类，封装一个BizException 异常，
   捕获异常后，记录日志，返回错误码和错误信息


测试
docker pull redis:6.2.16
docker run -d --name redis-6.2.16 -p 6379:6379 redis:6.2.16 redis-server --requirepass myredis